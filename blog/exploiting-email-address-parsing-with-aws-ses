<!DOCTYPE html>
<html lang="en">
<head>
  <title>Exploiting email address parsing with AWS SES - Nathan Davison</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="generator" content="GravCMS" />
    <meta name="description" content="nathandavison.com" />
  <link rel="shortcut icon" href="/user/themes/cacti/images/favicon.ico" />
  <link rel="alternate" type="application/rss+xml" title="My Blog" href="/rss.xml">

          
      <link href="/user/themes/cacti/css/style.css" type="text/css" rel="stylesheet">
<link href="/user/plugins/form/assets/form-styles.css" type="text/css" rel="stylesheet">
<link href="/user/plugins/youtube/css/youtube.css" type="text/css" rel="stylesheet">
<link href="/user/plugins/highlight/css/vs2015.css" type="text/css" rel="stylesheet">
<link href="/user/plugins/featherlight/css/featherlight.min.css" type="text/css" rel="stylesheet">
<link href="/user/plugins/login/css/login.css" type="text/css" rel="stylesheet">
    
  </head>
<body>

    <section id="navigation">

    <nav class="main-nav">
                                <a class="active" href="/">
                <span class="arrow">‚Üê</span>                                 Blog
            </a>
                                <a class="" href="/contact">
                                                contact
            </a>
                    </nav>
    </section>

    <section id="wrapper">
                            
        <div class="">
            <article class="post">
        <header>
            <h1>Exploiting email address parsing with AWS SES</h1>
            <h2 class="headline">January 27, 2020</h2>
        </header>
        <section id="post-body">
            <p>In this post I'm going to cover a technique I discovered recently to bypass user account email validation/verification in a web app I was testing. This app used AWS SES to send verification emails, and the domain of a user's verified email address was used to make some access control decisions in the app logic.</p>
<p>In an app such as this one where a certain email domain can grant certain privileges for a signed up user, a good target for pen testing is whether you can trick the app into treating your address as belonging to one domain, but the verification email goes to another. The impact of finding a bug like that would vary on what sort of importance the app places in the email address (or its domain) after validating it -  in this app's case, the domain of the user signing up determined what level of access they had once verified and authenticated so, basically, we're talking access control bypass and privilege escalation.</p>
<p>After butting up against a lot of failures, I eventually stumbled across the following payload to achieve access control bypass in the app:</p>
<pre><code>&lt;aaa@bbb.com&gt;ccc@ddd.com</code></pre>
<p>When instructed to send an email to this address, SES will send the message to <code>aaa@bbb.com</code> however, in this particular instance, the app was treating this signup attempt as belonging to the domain <code>ddd.com</code>. The concept of this vulnerability is somewhat similar to <a href="https://nathandavison.com/blog/haproxy-http-request-smuggling">HTTP request smuggling</a>, in that the "frontend" (the web app) is parsing a value (the email address) different to the "backend" (AWS SES), causing a desynchronisation between the two and their intepretation of the value.</p>
<p>This is a failure in the app's logic primarily, as the app was not applying enough validation to the address a user supplied, but it's also interesting that SES parses this address at all - from what I can determine, <a href="https://tools.ietf.org/html/rfc5322#section-3.4">RFC 5322</a> is fairly strict in that the <code>name-addr</code> spec of <code>[display-name] angle-addr</code> is only in that order, and not <code>angle-addr [display-name]</code>. However, the RFC also states that some legacy systems will use <code>angle-addr</code> with the <code>display-name</code> following inside a comment (i.e. between parentheses), which this payload isn't exactly, but it is somewhat close. The RFC also states the use of <code>name-addr</code> as opposed to this legacy format as a SHOULD and not a MUST. Either way, when you combine the app's faulty logic in determining the domain of the user being verified, and the somewhat relaxed address parsing by SES, you end up with a vulnerability that allows a user to signup as a member of an arbitrary domain.</p>
<p>A quick way to confirm that SES will handle this format is the following command using the AWS CLI - you'll need valid AWS creds configured in your environment, a valid from address allowed by the creds, and of course an email to target with the message, which may need to be verified if your AWS account is in sandbox mode:</p>
<pre><code>aws ses send-email --from 'xxx@yyy.com' --to '&lt;aaa@bbb.com&gt;ccc@ddd.com' --message 'Subject={Data=test,Charset=utf-8},Body={Text={Data=test,Charset=utf-8}}'</code></pre>
<p>The "test" message should arrive at the inbox you put in place of the <code>aaa@bbb.com</code>. Interestingly, the <code>ccc@ddd.com</code> display name doesn't appear anywhere in the raw email source, which suggests perhaps it is not being treated as a display name at all, but is simply being ignored by SES. With that said, the following payload will send an email to <code>aaa@bbb.com</code> and use a display name of <code>eee@fff.com</code>:</p>
<pre><code>&lt;aaa@bbb.com&gt;(eee@fff.com)ccc@ddd.com</code></pre>
<p>This more closely follows the legacy format touched upon earlier when referencing the RFC, as <code>eee@fff.com</code> is a comment inside parentheses (although the <code>ccc@ddd.com</code> is still non conforming).</p>
<p>The situation with the vulnerable app I encountered is <a href="https://medium.com/@fs0c131y/tchap-the-super-not-secure-app-of-the-french-government-84b31517d144">very similar to the writeup by "Elliot Alderson"</a> which resulted in a vulnerability being found in the Python email address parsing function <code>parseaddr</code> (CVE-2019-16056). Interestingly, for both pre and post CVE-2019-16056 versions of Python, <code>parseaddr</code> identifies <code>aaa@bbb.com</code> as the address in the above payload, which is consistent with SES and would avoid the disconnect between app and email server, so it seems a valid mitigation for any app (like the one I bypassed with the above payload) that uses SES would be to use a function like <code>parseaddr</code> which also extracts <code>aaa@bbb.com</code> from the payload. Like SES though, whether or not <code>parseaddr</code> <em>should</em> extract <code>aaa@bbb.com</code> from the payload as the email address rather than hit an error condition is another question.</p>
<p>What about other languages and packages that may be used to parse an address? Here I have some tests I've run against various languages and their popular functions and libraries for parsing email addresses:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Return when parsing <code>&lt;aaa@bbb.com&gt;ccc@ddd.com</code> payload</th>
<th>Vulnerable?</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python + email.utils.parseaddr()</td>
<td><code>aaa@bbb.com</code></td>
<td>Maybe</td>
</tr>
<tr>
<td>NodeJS + email-addressess</td>
<td><code>null</code></td>
<td>No</td>
</tr>
<tr>
<td>NodeJS + address-rfc2822</td>
<td><code>throw new Error('No results')</code></td>
<td>No</td>
</tr>
<tr>
<td>PHP + mailparse_rfc822_parse_addresses()</td>
<td>Array of <code>aaa@bbb.com</code> and <code>ccc@ddd.com</code></td>
<td>Yes</td>
</tr>
<tr>
<td>PHP + Mail_RFC822::parseAddressList()</td>
<td><code>Validation failed for: &lt;aaa@bbb.com&gt;ccc@ddd.com</code></td>
<td>No</td>
</tr>
<tr>
<td>PHP + PHPMailer</td>
<td><code>Invalid address:  (to): &lt;aaa@bbb.com&gt;ccc@ddd.com</code></td>
<td>No</td>
</tr>
<tr>
<td>Ruby + Mail::AddressList()</td>
<td><code>Mail::AddressList can not parse \|&lt;aaa@bbb.com&gt;ccc@ddd.com\|: Only able to parse up to "&lt;aaa@bbb.com&gt;"</code></td>
<td>No</td>
</tr>
<tr>
<td>C# + System.Net.Mail.MailAddress</td>
<td><code>An invalid character was found in the mail header: '&gt;'</code></td>
<td>No</td>
</tr>
<tr>
<td>Go + mail.ParseAddress()</td>
<td><code>mail: expected single address, got "ccc@ddd.com"</code></td>
<td>No</td>
</tr>
<tr>
<td>Java + email-rfc2822-validator EmailAddressParser.getAddressParts()</td>
<td><code>null</code></td>
<td>No</td>
</tr>
<tr>
<td>Java + javax.mail InternetAddress()</td>
<td><code>aaa@bbb.com</code></td>
<td>Maybe</td>
</tr>
</tbody>
</table>
<p>The "Vulnerable?" column is asking whether the output of the command could be vulnerable to allowing the payload to be parsed differently in the app code compared to where AWS SES will send the email or, in other words, was the execution successful/error free and does the output contain <code>ccc@ddd.com</code>? because if it does, it may be further interpreted by code as the email address. Of course, email platforms other than AWS SES may do the exact opposite, and send a message to <code>ccc@ddd.com</code> instead of <code>aaa@bbb.com</code> when fed the payload - this is why, if the method above returns any valid data at all instead of raising an error, I list it as "Maybe" vulnerable, as it could create a vulnerability in an app when paired with the "wrong" mail backend.</p>
<p>With that said, I considered the PHP <code>mailparse_rfc822_parse_addresses()</code> to be vulnerable because it returns the <code>ccc@ddd.com</code> in the array (albeit in the last array element), which could lead to code parsing the payload as an email being sent to <code>ccc@ddd.com</code>. For instance, the following (somewhat contrived) PHP code would consider <code>ddd.com</code> to be the domain the user signed up with when given the <code>&lt;aaa@bbb.com&gt;ccc@ddd.com</code> payload:</p>
<pre><code class="language-php">function get_signup_domain($email) {
        // strip out commas and semi colons
        $email = str_replace([",", ";"], "", $email);
        // get the address
        $addr_a = mailparse_rfc822_parse_addresses($email);
        $addr = end($addr_a)['address'];
        // return the domain
        return substr($addr, strpos($addr, "@") + 1);
}</code></pre>
<p>The code is stripping out symbols that might be used to combine email addresses, signifying a developer's effort to prevent multiple addresses being provided.</p>
<p>Because the payload still works with SES with some modifications (such as the <code>&lt;aaa@bbb.com&gt;(eee@fff.com)ccc@ddd.com</code> one mentioned already), I also tried variations of the payload to see if the outcome changed across the languages - most of the time the result was the same as above, but there was one noteable exception with this comment payload:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Return when parsing <code>&lt;aaa@bbb.com&gt;(eee@fff.com)ccc@ddd.com</code> payload</th>
</tr>
</thead>
<tbody>
<tr>
<td>C# + System.Net.Mail.MailAddress</td>
<td><code>"&lt;aaa@bbb.com&gt;" &lt;ccc@ddd.com&gt;</code></td>
</tr>
</tbody>
</table>
<p>When given <code>&lt;aaa@bbb.com&gt;(eee@fff.com)ccc@ddd.com</code>, the .NET <code>System.Net.Mail.MailAddress</code> method will return <code>"&lt;aaa@bbb.com&gt;" &lt;ccc@ddd.com&gt;</code> rather than the <code>An invalid character was found in the mail header: '&gt;'</code> error from the original payload. This also works with a space character instead of <code>(eee@fff.com)</code>, i.e. a payload of:</p>
<pre><code>&lt;aaa@bbb.com&gt; ccc@ddd.com</code></pre>
<p>This non-error return is problematic, because it may be possible for code to take this return and determine that <code>ccc@ddd.com</code> is the address receiving the email. Luckily, if you feed this output directly to SES, <code>ccc@ddd.com</code> will get the email because it correctly parses the quotes and <code>&lt;aaa@bbb.com&gt;</code> becomes the display name, so there is no disconnect between code and mail backend in that scenario. The issue would be if <code>System.Net.Mail.MailAddress</code> was used to validate and extract the domain out of the address, but the original payload was sent directly to SES as the 'to' address, such as in the following snippet:</p>
<pre><code class="language-csharp">// this is the value the user provided during signup
string UserEmail = "&lt;aaa@bbb.com&gt; ccc@ddd.com";

// parse and validate the user provided email address
try {
        System.Net.Mail.MailAddress ParsedEmailAddress = new System.Net.Mail.MailAddress(UserEmail);
} catch (Exception ex) {
        ...
}

// no exception caught - validation passed! get the domain of the user's email address, and store it for later use in business logic/access control
string UserDomain = ParsedEmailAddress.Host;

// UserDomain is "ddd.com"

// send the email to the user via AWS SES, using the original validated payload
sendValidationEmailViaSES(UserEmail);

// email was sent to "aaa@bbb.com"</code></pre>
<p>You can see the parsing in action with <a href="https://dotnetfiddle.net/HYfHci">this dotnetfiddle.net snippet</a>.</p>
<p>The <code>UserDomain</code> here will be <code>ddd.com</code> and, because it passed <code>System.Net.Mail.MailAddress</code>'s validation, the original <code>&lt;aaa@bbb.com&gt; ccc@ddd.com</code> payload is trusted and used to send the verification email via SES, which will send the email to <code>aaa@bbb.com</code>. Once verified, the user account is associated with the <code>ddd.com</code> domain in the app, but the email was never sent to an inbox under the <code>ddd.com</code> domain.</p>
<p>The catch here is the developer would have to implement <code>sendValidationEmailViaSES</code> in a specific way - Amazon's own <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-using-smtp-net.html">snippet of code on how to send an email in C# using SES</a> has the following line:</p>
<pre><code class="language-csharp">message.To.Add(new MailAddress(TO));</code></pre>
<p>This should prevent the vulnerability, because as shown, <code>MailAddress</code> will convert the payload into the compliant <code>"&lt;aaa@bbb.com&gt;" &lt;ccc@ddd.com&gt;</code> string. However, if the <code>sendValidationEmailViaSES</code> implementation instead did this:</p>
<pre><code class="language-csharp">message.To.Add(TO);</code></pre>
<p>Then the message will be sent to SES with the payload intact, and the vulnerability would be in play. As mentioned, a developer may be inclined to do this, because the address was parsed and validated by <code>System.Net.Mail.MailAddress</code>.</p>
<p>The results across the languages suggest that this payload won't be effective in mass exploiting many web applications, however keep in mind these are functions and libraries built for parsing email addresses - if Google results for searches like "parse email addresses LANGUAGE_HERE" are anything to go by, a lot of developers will be following bad advice such as "just split on the last '@' symbol to get the email domain", which is probably what caused the app I was testing to be vulnerable. On the other hand, even if you do use a parser, you should still be wary of edge cases like those I listed - sometimes their output can be wrong or misleading, or at the very least too liberal in accepting non conforming addresses, and prone to introducing vulnerabilities. At the very least, a developer should make sure to investigate whether there is a better way in their language of choice to validate an email address beyond running an email parsing function and looking for errors (for instance, in PHP, use <code>filter_var()</code> with <code>FILTER_VALIDATE_EMAIL</code>), and use the output of the parser when sending the email even if the original payload was parsed successfully (which avoids the issue in the <code>System.Net.Mail.MailAddress</code> example).</p>
<h2>Reporting</h2>
<p>As a result of this research, I reported the following:</p>
<ul>
<li><a href="https://bugs.php.net/bug.php?id=78871">mailparse_rfc822_parse_addresses parsing bug</a>. The maintainers don't believe this is a security issue in PHP as users shouldn't be using this function for email validation.</li>
<li>AWS don't consider the error-free parsing of the payload to be an issue on their end, saying "The issue you reported is caused by improper client-side validation within web applications which use Amazon SES".</li>
<li>I couldn't find a way to report System.Net.Mail.MailAddress's parsing of the modified payload to Microsoft, and failed to get past triage in their .NET bug bounty process.</li>
</ul>
        </section>
    </article>
    <footer id="post-meta" class="clearfix">
        <a href="http://twitter.com/nj_dav">
            <img class="avatar" src="/user/themes/cacti/images/avatar.png">
            <div>
                <span class="dark">Nathan Davison</span>
                <span>Blogging about web security stuff</span>
            </div>
        </a>

        <section id="sharing">
            <a class="twitter" href="https://twitter.com/intent/tweet?text=Exploiting email address parsing with AWS SES by @nj_dav - http://localhost/blog/exploiting-email-address-parsing-with-aws-ses"><span class="icon-twitter"> Tweet</span></a>
<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>
        </section>
    </footer>

    <nav id="post-nav" class="clearfix">
                <span class="prev">
            <a href="/blog/cache-poisoning-dos-in-cloudfoundry-gorouter"><span class="arrow">‚Üê</span> Cache poisoning DoS in CloudFoundry gorouter (CVE-2020-5401)</a>
        </span>
        
                <span class="next">
            <a href="/blog/abusing-http-hop-by-hop-request-headers">Abusing HTTP hop-by-hop request headers <span class="arrow">‚Üí</span></a>
        </span>
            </nav>


    <!-- Disqus comments -->
    
    <!-- Archive post list -->
    
            </div>

                <footer id="footer">
    <p class="small">¬© Copyright 2023</p>
</footer>
            </section>

        
                      
      <script src="/assets/ab993aa8955cc9b4d8ab5a20cb172675.js"></script>
<script>
hljs.initHighlightingOnLoad();
</script>
<script>
$(document).ready(function(){
    $('a[rel="lightbox"]').featherlight({
        openSpeed: 250,
        closeSpeed: 250,
        closeOnClick: 'background',
        closeOnEsc: '1',
        root: 'body'
    });
});
</script>

    
  </body>
</html>
